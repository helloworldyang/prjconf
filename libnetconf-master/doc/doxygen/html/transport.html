<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libnetconf: Transport Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="usage.html">Using libnetconf</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="transport">Transport Protocol </a></h1><p>[RFC6241]: <a href="http://tools.ietf.org/html/rfc6241">http://tools.ietf.org/html/rfc6241</a> "RFC 6241" [RFC5539bis]:<a href="http://tools.ietf.org/html/draft-ietf-netconf-rfc5539bis-05">http://tools.ietf.org/html/draft-ietf-netconf-rfc5539bis-05</a> "RFC 5539bis" [netopeer]:<a href="https://code.google.com/p/netopeer/">https://code.google.com/p/netopeer/</a> "Netopeer"</p>
<p>NETCONF protocol specifies the set of requirements for the transport protocol in [RFC 6241][RFC6241]. There are currently 2 specifications how to use specific transport protocols for NETCONF: [RFC 6242][RFC6242] for Secure SHell (SSH) and [RFC 5539bis][RFC5539bis] for Transport Layer Security (TLS). SSH is mandatory transport for NETCONF implementations.</p>
<p>libnetconf supports SSH transport out of the box. From version 0.8, there is also experimental support for TLS transport. By default, this is not available by default. To enable TLS transport, following action must be performed:</p>
<ul>
<li>run configure with `--enable-tls` option: ~~~~ ./configure --enable-tls ~~~~</li>
</ul>
<p>See the [Netopeer project][netopeer] as a reference implementation.</p>
<h2><a class="anchor" id="transport-client">
Transport Support on the Client Side</a></h2>
<p>To switch from the default SSH transport to the TLS transport, application must call <a class="el" href="db/d52/group__session.html#ga6e125c035cdebae8c49ff962866c0806" title="Set transport protocol for the sessions created by subsequent nc_session_connect()...">nc_session_transport()</a> with <a class="el" href="db/d52/group__session.html#gga8be6ccea205129b05c38331a7a42174aa9dfde07fbf3ce02396167716ef70c612">NC_TRANSPORT_TLS</a> parameter. Remember, that this change applies only to the current thread.</p>
<p>Next step is to initiate TLS context for the new NETCONF session. Using <a class="el" href="db/db4/group__tls.html#gacbf946a826fa6c7c18a4e66d532b659f" title="Set paths to the client certificate and its private key.">nc_tls_init()</a> function, client is supposed to set its client certificate and CA for server certificate validation.</p>
<p>Now the TLS context is ready and new NETCONF session over TLS can be established using <a class="el" href="db/d52/group__session.html#gae3858d998d19cb2fb700b15fdf602f23" title="Create NETCONF session to the specified server.">nc_session_connect()</a>. Application can run <a class="el" href="db/db4/group__tls.html#gacbf946a826fa6c7c18a4e66d532b659f" title="Set paths to the client certificate and its private key.">nc_tls_init()</a> again, but the changed parameters will be applied only to the newly created NETCONF sessions.</p>
<p>To properly clean all resources, call <a class="el" href="db/db4/group__tls.html#gacf3aed5cccac55d0548f46761707ece9" title="Destroy all resources allocated for preparation of TLS connections.">nc_tls_destroy()</a>. It will destroy TLS connection context. This function can be called despite the running NETCONF session, but creating a new NETCONF session over TLS is not allowed after calling <a class="el" href="db/db4/group__tls.html#gacf3aed5cccac55d0548f46761707ece9" title="Destroy all resources allocated for preparation of TLS connections.">nc_tls_destroy()</a> - the client has to call <a class="el" href="db/db4/group__tls.html#gacbf946a826fa6c7c18a4e66d532b659f" title="Set paths to the client certificate and its private key.">nc_tls_init()</a> again.</p>
<p>The whole process described here is supposed to be performed in a single thread. SSH transport works out of the box, so no specific step, as mentioned for TLS in this section, is required.</p>
<h2><a class="anchor" id="transport-server">
Transport Support on the Server Side</a></h2>
<p>There is no specific support for neither SSH or TLS on the server side. libnetconf doesn't implement SSH nor TLS server - it is expected, that NETCONF server application uses external application (sshd, stunnel,...) serving as SSH/TLS server and providing NETCONF data to the NETCONF server stdin, where libnetconf can read the data, and getting data from the NETCONF server stdout to encapsulate the data and send to a client.</p>
<p>For both cases, SSH as well as TLS, there are two functions: <a class="el" href="db/d52/group__session.html#gad0e758dfee764ae9c2a032e0151c6707" title="Accept NETCONF session from a client.">nc_session_accept()</a> and <a class="el" href="db/d52/group__session.html#ga7ee207cac84fd5cd82419af41e14c06f" title="Accept NETCONF session from a client and assign it to the specified username.">nc_session_accept_username()</a>, that serve to accept incoming connection despite the transport protocol. As mentioned, they read data from stdin and write data to the stdout. Difference between those functions is in recognizing NETCONF username. <a class="el" href="db/d52/group__session.html#gad0e758dfee764ae9c2a032e0151c6707" title="Accept NETCONF session from a client.">nc_session_accept()</a> guesses username from the process's UID. For example, in case of using SSH Subsystem mechanism in OpenSSH implementation, SSH daemon automatically changes UID of the launched SSH Subsystem process (NETCONF server/agent) to the UID of the logged user. But in case of other SSH/TLS server, this doesn't have to be done. In such a case, NETCONF server itself is supposed to correctly recognize the NETCONF username and specify it explicitly when establishing NETCONF session using <a class="el" href="db/d52/group__session.html#ga7ee207cac84fd5cd82419af41e14c06f" title="Accept NETCONF session from a client and assign it to the specified username.">nc_session_accept_username()</a>. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Dec 2015 for libnetconf by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
