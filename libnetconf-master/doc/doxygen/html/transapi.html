<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libnetconf: Transaction API (transAPI)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="transapi">Transaction API (transAPI) </a></h1><p>Libnetconf transAPI is a framework designed to save developers time and let them focus on configuring and managing their device instead of fighting with the NETCONF protocol.</p>
<p>It allows a developer to choose parts of a configuration that can be easily configured as a single block. Based on a list of so called 'sensitive paths' the generator creates C code containing a single callback function for every 'sensitive path'. Whenever something changes in the configuration file, the appropriate callback function is called and it is supposed to reflect configuration changes in the actual device behavior.</p>
<p>Additionaly, transAPI provides an opportunity to implement behavior of NETCONF RPC operation defined in the data model. In case *lnctool(1)* finds an RPC definition inside the provided data model, it generates callbacks for it too. Whenever a server calls <a class="el" href="db/d67/group__store.html#ga6e6e979bd82e50913c82b4dc37cb8759" title="Perform the requested RPC operation on the all datastores controlled by the libnetconf...">ncds_apply_rpc2all()</a> with RPC message containing such defined RPC operation, libnetconf uses callback function implemented in the module.</p>
<h2><a class="anchor" id="understanding-parameters">
Understanding callback parameters</a></h2>
<p>Every <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a> callback function has fixed set of parameters. Function header looks like this:</p>
<p>~~~~~~~{.c} int callback_path_into_configuration_xml(void **data, XMLDIFF_OP op, xmlNodePtr old_node, xmlNodePtr new_node, struct nc_err **error) ~~~~~~~</p>
<h3><a class="anchor" id="data">
void **data</a></h3>
<p>This parameter was added to provide a way to share any data between callbacks. libnetconf never change (or even access) content of this parameter. Initialy content of 'data' is NULL. <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a> module may use 'data' as it like but is also fully responsible for correct memory handling and freeing of no longer needed memory referenced by 'data'.</p>
<h3><a class="anchor" id="op">
XMLDIFF_OP op</a></h3>
<p>Parameter op indicates what event(s) was occured on node. All events are bitwise ored. To test if certaint event occured on node use bitwise and (&amp;).</p>
<ul>
<li>Node can be added or removed.<ul>
<li>XMLDIFF_ADD = Node was added.</li>
<li>XMLDIFF_REM = Node was removed.</li>
</ul>
</li>
<li>Nodes of type leaf can be changed.<ul>
<li>XMLDIFF_MOD = Node content was changed.</li>
</ul>
</li>
<li>Container nodes are informed about events occured on descendants. It can be distinguished whether the event was processed or not.<ul>
<li>XMLDIFF_MOD = Some of node children was changed and there is not callback specified for it.</li>
<li>XMLDIFF_CHAIN = Some of node children was changed and associated callback was called.</li>
</ul>
</li>
<li>Additionaly, user-ordered lists and leaf-lists are notified when change in order occurs.<ul>
<li>XMLDIFF_SIBLING = Change in order. Some of siblings was added, removed or changed place.</li>
<li>XMLDIFF_REORDER = Undrelying user-ordered list has changed order.</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="combinations">
Valid combinations of events</a></h4>
<ul>
<li>XMLDIFF_ADD and XMLDIFF_REM can never be specified simutaneously.</li>
<li>other restrictions depend on node type:<ul>
<li>Leaf: exactly one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD</li>
<li>Container: at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>List (system-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>List (user-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN, XMLDIFF_SIBLING and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>Leaf-list (system-ordered): exactly one of XMLDIFF_ADD, XMLDIFF_REM</li>
<li>Leaf-list (user-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_SIBLING</li>
</ul>
</li>
</ul>
<p>Ex.: Leaf processing ~~~~~~~{.c} int callback_some_leaf(void **data, XMLDIFF_OP op, xmlNodePtr old_node, xmlNodePtr new_node, struct nc_err **error) { if (op &amp; XMLDIFF_MOD) { // change configured value } else if (op &amp; XMLDIFF_REM) { // leaf removed (disable service, close port, ...) } else if (op &amp; XMLDIFF_ADD) { // leaf added (enable service, open port, ...) } else { *error = nc_err_new(NC_ERR_OP_FAILED); nc_err_set(error, NC_ERR_PARAM_MSG, "Invalid event for leaf node /some/leaf."); return(EXIT_FAILURE); } return(EXIT_SUCCESS); } ~~~~~~~</p>
<h3><a class="anchor" id="node">
xmlNodePtr old_node &amp; new_node</a></h3>
<p>Pointer to a particular node instance in either the old or new configuration document, in which the event was detected. When the node was removed, new node is not set and when the node was deleted, old node is not set. It is safe to traverse the whole document using these pointers, but should be used only when necessary, since transAPI itself does this for you.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is safe to traverse these nodes, but any modification will normally be lost. If you need to change some nodes, you can do so, but only in the new_node subtree (not available on XMLDIFF_REM). Then, for these changes to be written to the datastore, change 'config_modified' to 1. This variable is generated into every module.</dd></dl>
<h3><a class="anchor" id="error">
strict nc_err **error</a></h3>
<p>libnetconf's error structure. May (and should) be used to specify error when it occurs and callback returns EXIT_FAILURE. Error description is forwarded to client.</p>
<h2><a class="anchor" id="transAPI-history">
History of the transAPI versions</a></h2>
<p>Each transAPI module source code is generated with the ``transapi_version`` variable set to the transAPI version supported by the code generator (*lnctool(1)*). libnetconf requires exactly the same transAPI version in the modules as it supports itself. However, some of the transAPI versions are kind of backward compatible, so it is possible to simply change the value of the ``transapi_version`` variable in the module source code. In that case no additional changes to the transAPI module source code are required.</p>
<p>Here is the list of transAPI versions with notes to the changed things and to the backward compatibility.</p>
<ul>
<li>*version 1*<ul>
<li>Initial reversion.</li>
</ul>
</li>
<li>*version 2*<ul>
<li>Allow callbacks to modify configuration data. This action is announced by the callback via the ``config_modified`` variable.</li>
<li>Changes prototype of the transAPI callbacks. It allows to return NETCONF error description structure from the callbacks.</li>
<li>Backward incompatible.</li>
</ul>
</li>
<li>*version 3*<ul>
<li>Changes prototype of the ``transapi_init()`` function. It allows the module can announce to libnetconf the initial configuration of the device when the module is loaded.</li>
<li>Changes prototype of the transAPI callbacks. The configuration data are passed to the callbacks only as the libxml2 structures. Callbacks variant passing configuration data as strings are no longer available.</li>
<li>Backward incompatible.</li>
</ul>
</li>
<li>*version 4*<ul>
<li>Callback order - the module can change the order of executing callbacks from the default 'from leafs to root` to 'from root to leafs`. This is done via the ``callbacks_order`` variable. If the variable is not defined (such as in a transAPI v3 module), the default callback order is used.</li>
<li>Backward compatible.</li>
</ul>
</li>
<li>*version 5*<ul>
<li>Adds support for monitoring external files.</li>
<li>Backward compatible.</li>
</ul>
</li>
<li>*version 6*<ul>
<li>Every data callback now receives the corresponding node from both the old configuration and the new configuration. This holds for every operation except XMLDIFF_ADD (the old node is NULL) and XMLDIFF_REM (the new node is NULL).</li>
<li>Every RPC callback now receives a list of all the arguments and it is up to developers to parse them themselves. To help with this, a simple function get_rpc_node() is included in a transAPI module code.</li>
<li>Backward incompatible.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="transapiTutorial">
transAPI Tutorial</a></h2>
<p>[netopeer]: <a href="https://code.google.com/p/netopeer">https://code.google.com/p/netopeer</a></p>
<p>On this page we will show how to write a simple module for controlling an example Turing machine. The full implementation can be found in the [Netopeer project](<a href="https://code.google.com/p/netopeer">https://code.google.com/p/netopeer</a>). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>To install libnetconf follow the instructions on the <a class="el" href="install.html">Compilation and Installation</a> page.</dd></dl>
<h3><a class="anchor" id="transapiTutorial-prepare">
Preparations</a></h3>
<p>In this example we will work with the data model of a Turing machine provided by the Pyang project (&lt;<a href="https://code.google.com/p/pyang/source/browse/trunk/doc/tutorial/examples/turing-machine.yang">https://code.google.com/p/pyang/source/browse/trunk/doc/tutorial/examples/turing-machine.yang</a>&gt;).</p>
<p>First, we need to identify important parts of the configuration data. Since the turing-machine data model describes only one configurable subtree, we have an easy choice. So, we can create the 'paths_file' file containing the specification of our chosen element and mapping prefixes with URIs for any used namespace.</p>
<p>Our file may look like this (irrespective of order): ~~~~~~~{.xml} tm=http://example.net/turing-machine /tm:turing-machine/tm:transition-function/tm:delta ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-generating">
Generating code</a></h3>
<ol type="1">
<li>Create a new directory for the turing-machine module and move the data model and the path file into it: ~~~~~~~{.sh} $ mkdir turing-machine &amp;&amp; cd turing-machine/ $ mv ../turing-machine.yang ../paths_file . ~~~~~~~</li>
<li>Run *lnctool(1)* for <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a>: ~~~~~~~{.sh} $ lnctool --model ./turing-machine.yang <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a> --paths ./paths_file ~~~~~~~</li>
</ol>
<p>Besides the generated source code of our transAPI module and GNU Build System files (Makefile.in, configure.in,...), *lnctool(1)* also generates YIN format of the data model and validators accepted by the libnetconf's <a class="el" href="d8/d55/group__transapi.html#ga80e69b4cada8c35e5e358287e8af3d85" title="Create new datastore structure with transaction API support.">ncds_new_transapi()</a> and <a class="el" href="db/d67/group__store.html#ga4777c16043f5856c5a65bcd20b5ecc31" title="Set validators (or disable validation) on the specified datastore.">ncds_set_validation()</a> functions:</p>
<ul>
<li>*.yin - YIN format of the data model</li>
<li>*.rng - RelagNG schema for syntax validation</li>
<li>*-schematron.xsl - Schematron XSL stylesheet for semantics validation</li>
</ul>
<p>The data model can define various `feature`s and use them via the `if-feature` clauses. By default, all features are enabled for the validators. If you plan to to implement only a specific set (or none) of features, specify it to using the `--feature`` option (that can be used multiple times). The value has the following syntax:</p>
<p>~~~~~~~{.sh} --feature module_name:feature_to_enable ~~~~~~~</p>
<p>If you want to disable all features of the module, use the following syntax:</p>
<p>~~~~~~~{.sh} --feature module_name: ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-augmenting">
Augmenting module</a></h3>
<p>When you are adding a model augmenting the original model, you have generally 2 ways of doing so: <br/>
</p>
<ol type="1">
<li>Create a new transAPI module implementing the original model with any augments, basically treating it as a single model. This way you receive a standalone transAPI module that will make the original module obsolete. *lnctool(1)* command: ~~~~~~~{.sh} $ lnctool --model &lt;original_model&gt; --augment-model &lt;augment_model&gt; <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a> --path &lt;paths_for_original_and_augment_model&gt; ~~~~~~~ <br/>
</li>
<li>Create a new transAPI module implementing only the augmented parts. This way you receive an additional module that will be used together with the original module, which does not need to be modified in any way. *lnctool(1)* command: ~~~~~~~{.sh} $ lnctool --model &lt;augment_model&gt; <a class="el" href="d9/dc0/structtransapi.html" title="Structure to describe transAPI module and connect it statically with libnetconf using...">transapi</a> --path &lt;paths_for_augment_model&gt; ~~~~~~~</li>
</ol>
<p><br/>
 However, the case when a model is augmenting an RPC in the original model is special and ONLY the first way of augmenting a module can and MUST be used.</p>
<h3><a class="anchor" id="transapiTutorial-coding">
Filling up functionality</a></h3>
<p>Here we show a turing-machine simulating module. The full implementation can be found in the [Netopeer project][netopeer] repository (transAPI/turing/turing-machine.c). The example functions and all the code is simplified and NOT thread-safe.</p>
<ol type="1">
<li>Open 'turing-machine.c' file with your favorite editor:<br/>
<br/>
 ~~~~~~~{.sh} $ vim turing-machine.c ~~~~~~~ <br/>
</li>
<li>Add global variables and auxiliary functions. This is completely up to you, libnetconf does not work with this anyway. For full explanation of this code look into the referenced working example. It should be called to run the Turing machine, once set up, but some parts were omitted.<br/>
<br/>
 ~~~~~~~{.c} static tape_symbol *tm_head = NULL; static tape_symbol *tm_tape = NULL; static cell_index tm_tape_len = 0; static state_index tm_state = 0; static struct delta_rule *tm_delta = NULL;</li>
</ol>
<p>static void* tm_run(void *arg) { int changed = 1; struct delta_rule *rule = NULL;</p>
<p>while(changed) { changed = 0;</p>
<p>if (tm_head &lt; tm_tape || (tm_head - tm_tape) &gt;= tm_tape_len) { break; }</p>
<p>for (rule = tm_delta; rule != NULL; rule = rule-&gt;next) { if (rule-&gt;in_state == tm_state &amp;&amp; rule-&gt;in_symbol == tm_head[0]) { if (rule-&gt;out_state != 0xffff) { tm_state = rule-&gt;out_state; } tm_head[0] = rule-&gt;out_symbol; tm_head = tm_head + rule-&gt;head_move;</p>
<p>changed = 1;</p>
<p>usleep(100); break; } } }</p>
<p>return (NULL); } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Complete the 'transapi_init()' function with actions that will be run right after the module loads and before any other function in the module is called.<br/>
<br/>
 The 'running' parameter can optionally return the current configuration state of the device as the 'transapi_init()' detects it. The configuration must correspond with the device data model and it is supposed to contain only the configuration data (defined with 'config true`). The returned data are then compared with the startup configuration and only the diverging values are set according to the startup content using the appropriate transAPI callback functions.<br/>
<br/>
 We ignore it in our example - the Turing machine does not have any configuration that could be read from (depend on the state of) the system.</li>
</ol>
<dl class="note"><dt><b>Note:</b></dt><dd>After returning from 'transapi_init()' it is assumed that the current running configuration reflects the actual state of the controlled device. For instance, if the model includes some default values and the running configuration is empty, libnetconf assumes that the device is in this default state as defined in the model. If not, then you should apply the default configuration on the device in 'transapi_init()'.</dd></dl>
<p><br/>
 ~~~~~~~{.c} int transapi_init(xmlDocPtr *running) { return EXIT_SUCCESS; } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Locate the 'transapi_close()' function and fill it with actions that will be run just before the module unloads. No other function of the transAPI module is called after the 'transapi_close()'. We free up all the temporary variables used to store the current state of the machine.<br/>
<br/>
 ~~~~~~~{.c} void transapi_close(void) { struct delta_rule *rule;</li>
</ol>
<p>free(tm_tape);</p>
<p>for (rule = tm_delta; rule != NULL; rule = tm_delta) { tm_delta = rule-&gt;next; free_delta_rule(rule); } } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Fill 'get_state_data()' function. This function returns (only!) the state data (defined with 'config false').<br/>
<br/>
 ~~~~~~~{.c} char * get_state_data(char * model, char * running, struct nc_err **err) { return strdup("&lt;?xml version="1.0"?&gt;&lt;turing-machine xmlns="<a href="http://example.net/turing-machine">http://example.net/turing-machine</a>"&gt; ... &lt;/turing-machine&gt;"); } ~~~~~~~ <br/>
</li>
<li>Complete the configuration callbacks (they have the `callback_` prefix). The 'op' parameter can be used to determine operation which was done with the node. Parameter 'old_node' holds a copy of node before the change and 'new_node' after the change. More detailed information about the callback parameters can be found above in the <a class="el" href="transapi.html#understanding-parameters">Understanding callback parameters</a> section.<br/>
<br/>
 In this code, we treat modification as a removal and an immediate addition to limit branching and simplifiy the code. ~~~~~~~{.c} int callback_tm_turing_machine_tm_transition_function_tm_delta(void **data, XMLDIFF_OP op, xmlNodePtr old_node, xmlNodePtr new_node, struct nc_err **error) { char *content = NULL; xmlNodePtr n1, n2; struct delta_rule *rule = NULL;</li>
</ol>
<p>if (op &amp; XMLDIFF_MOD) { op = op | (XMLDIFF_REM &amp; XMLDIFF_ADD); }</p>
<p>if (op &amp; XMLDIFF_REM) { //remove the rule from the internal list }</p>
<p>if (op &amp; XMLDIFF_ADD) { //parse the children of new_node and add the new rule to the list }</p>
<p>return EXIT_SUCCESS; } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Fill the RPC message callback functions with the code that will be run when an RPC message with the defined operation arrives.<br/>
<br/>
 The RPC defines an optional parameter 'tape-content', so we use it if specified, otherwise use the default value.<br/>
<br/>
 ~~~~~~~{.c} nc_reply *rpc_initialize(xmlNodePtr input) { xmlNodePtr tape_content = get_rpc_node("tape-content", input); struct nc_err* e = NULL;</li>
</ol>
<p>free(tm_tape);</p>
<p>tm_state = 0; tm_tape = tm_head = (char*)xmlNodeGetContent(tape_content);</p>
<p>if (tm_tape == NULL) { tm_tape = tm_head = strdup(""); }</p>
<p>tm_tape_len = strlen(tm_tape) + 1; pthread_mutex_unlock(&amp;tm_run_lock);</p>
<p>return <a class="el" href="d0/de2/group__reply.html#ga047f565bb3671ec4016fef5461e8f67e" title="Create &lt;ok&gt; rpc-reply response.">nc_reply_ok()</a>; } ~~~~~~~ <br/>
 To run the machine, we create another thread and let it run in the background. There are no parameters, so we ignore the input.<br/>
<br/>
 ~~~~~~~{.c} nc_reply *rpc_run(xmlNodePtr input) { pthread_t tm_run_thread; struct nc_err *e; char *emsg = NULL; int r;</p>
<p>if ((r = pthread_create(&amp;tm_run_thread, NULL, tm_run, NULL)) != 0) { e = nc_err_new(NC_ERR_OP_FAILED); asprintf(&amp;emsg, "Unable to start turing machine thread (%s)", strerror(r)); nc_err_set(e, NC_ERR_PARAM_MSG, emsg); free(emsg); return nc_reply_error(e); }</p>
<p>pthread_detach(tm_run_thread);</p>
<p>return <a class="el" href="d0/de2/group__reply.html#ga047f565bb3671ec4016fef5461e8f67e" title="Create &lt;ok&gt; rpc-reply response.">nc_reply_ok()</a>; } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Optionally, you can set monitoring for some external configuration file.<br/>
<br/>
 Let's say, that our Turing machine has a textual configuration located in the `/etc/turing.conf` file. libnetconf can monitor this file for modification and whenever an external application changes content of the file, the specified callback is executed. It's up to the callback function to open the file for reading and get the current configuration data.<br/>
<br/>
 ~~~~~~~{.c} int example_callback(const char *filepath, xmlDocPtr *running, int* execflag) { // do nothing *running = NULL; *execflag = 0;</li>
</ol>
<p>return EXIT_SUCCESS; }</p>
<p>struct <a class="el" href="de/df8/structtransapi__file__callbacks.html" title="Functions to call if the specified file is modified.">transapi_file_callbacks</a> file_clbks = { .callbacks_count = 1, .callbacks = {{.path = "/etc/turing.conf", .func = example_callback}} }; ~~~~~~~ <br/>
 Here is the description of the callback function parameters:<br/>
</p>
<ul>
<li>**const char *filepath** - input parameter providing the path to the changed file</li>
<li>**xmlDocPtr *edit_config** - output parameter to return content for the `edit-config` operation to change the content of the NETCONF running datastore.</li>
<li>**int *exec** - output parameter to set if the performed changes should cause execution of the regular transAPI callbacks. If set to `0`, the changes are only reflected in the running configuration datastore, but no transAPI callback is executed.<br/>
<br/>
</li>
</ul>
<p>Done</p>
<h3><a class="anchor" id="transapiTutorial-compiling">
Compiling module</a></h3>
<p>Following sequence of commands will produce the shared library 'turing-machine.so' which may be loaded into libnetconf: ~~~~~~~{.sh} $ autoreconf --force --install $ ./configure $ make ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-using">
Integrating to a server</a></h3>
<p>In a server we use libnetconf's function <a class="el" href="d8/d55/group__transapi.html#ga80e69b4cada8c35e5e358287e8af3d85" title="Create new datastore structure with transaction API support.">ncds_new_transapi()</a> instead of <a class="el" href="db/d67/group__store.html#ga69009c5985f9eec3a6920f98a6a1a5e6" title="Create a new datastore structure of the specified implementation type.">ncds_new()</a> to create a transAPI-capable data store. Then, you do not need to process any data-writing (edit-config, copy-config, delete-config, lock, unlock), data-reading (get, get-config) or module data-model-defined RPC operations. All these operations are processed inside the <a class="el" href="db/d67/group__store.html#ga6e6e979bd82e50913c82b4dc37cb8759" title="Perform the requested RPC operation on the all datastores controlled by the libnetconf...">ncds_apply_rpc2all()</a> function. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Dec 2015 for libnetconf by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
